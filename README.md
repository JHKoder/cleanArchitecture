
## SOLID
### 단일 책임 원칙 SRP

---

단일 책임 원칙의 실제 정의는 다음과 같다<br>
`컴포넌트를 변경하는 이유는 오직 하나 뿐이어야 한다.`<br>
보시다 시피 `책임`은 사실 `오로지 한 가지 일만 하는 것`보다는 `변경할 이유`로 해석해야 한다.<br>
<br>
아마도 단일 책임 원칙을  `단일 변경 이유 원칙`으로 바꿔야 할지도 모르겠다.

### 의존 역전 원칙 DIP

---

`코드상의 어떤 의존성이든 그 방향을 바꿀수(역전시킬 수)있다.`

사실 의존성의 양쪽 코드를 모두 제어할 수 있을 때만 의존성을 역전시킬 수 있다. <br>
만약 서드파티 라이브러리에 의존성이 있다면 해당 라이브러리를 제어할 수 없기<br>
때문에 이 의존성은 역전시킬 수 없다. 

> 도메인 코드를 '변경할 이유'의 개수를 줄여보자
- 변동성이 큰 구체 클래스를 참조하지 마라
- 변동성이 큰 구체 클래스로부터 파생하지 마라
- 궤 함수를 오버라이드 하지 마라 
- 구체적이며 변동성이 크다면 절대로 그 이름을 언급하지마라 

### 개방 폐쇄 원칙 OCP

---

`소프트웨어 개체는 확장에는 열려 있어야 하고, 변경에는 닫혀 있어야 한다.`

만약 요구사항을 살짝 확장하는 데 소프트웨어를 어멍나게 수정해야 하다면,  
그 소프트웨어 시스템을 설계한 아키텍트는 엄청난 실패에 맞닥뜨린 것이다.

소프트웨어 아키텍처가 홀륭하다면 변경되는 코드의 양이 가능한 한 최소화 될 것이다. 이상적인 변경량은 0이다.  
서로 다른 목적으로 변경되는 요소를 적절하게 분히하고(SRP) 이들 요소 사이의 의존성을 체계화함으로서(DIP)  
변경량을 최소화할 수 있다.  

OCP의 목표는 시스템을 확장하기 쉬운 동시에 변경으로 인해 시스템이 너무 많은 영향을 받지 않도록 하는데 있다.  
이목표를 달성하기 위해 필요한것
- 시스템을 컴포넌트 단위로 분리한다.
- 저서준 컴포넌트에서 발생한 변경으로부터 고수준 컴포넌트를 보호할 수 있는 형태의 의존성  
  계층구조가 만들어 지도록 해야 한다.


### 리스코프 치환 원칙

---

아키텍처 수준까지 확장할 수 있고, 반드시 확장해야만 한다.  
치환 가능성을 조금이라도 위배하면 시스템 아키텍처가 오염되어  
상당향의 별도 메커니즘을 추가해야 할 수 있기 때문이다.

> 상위 타입과 하위 타입이 바꿔도 문제가 없어야 한다.

### 인터페이스 분리 원칙 ISP 

---


-> : 하위 -> 상위 타입  
(I) :  인터페이스  
{ } : 내부 메소드

sample.1
```text
  User1 -> OPS
  User2 -> OPS
  User3 -> OPS
  
  OPS{
    op1();
    op2();
    op3();
  }
```

sample.2
```text
  User1 -> UserOps1
  User2 -> UserOps2
  User3 -> UserOps3
  
  (I)UserOps1{ op1() }
  (I)UserOps2{ op2() }
  (I)UserOps3{ op3() }
  
  OPS{
    -> UserOps1
    -> UserOps2
    -> UserOps3
  }
```



## 클린 아키텍처의 구조

---

> 웹 , 데이터베이스, UI, 외부 인터페이스 ,장치 
> ⬇
> > 컨트롤러, 게이트웨이, 프레젠터
> ⬇
> > > 유스케이스
> ⬇
> > > > 엔티티 


이 아키텍처에서 가장 주요한 규칙은 의존성 규칙으로, `계층간의 모든 의존성이 안쪽으로 향해`야 한다는 것이다.

유스케이스는 앞에서 서비스라고 불렸던 것들인데 단일 책임(즉, 변경할 단 한 가지의 이유)을<br>
갖기 위해 조금 더 세분화돼 있다. 이를 통해 넓은 서비스의 문제를 피할 수 있다.

도메인 코드에서는 어떤 것이 사용되는지 알 수 없기 때문에 특정 프레임워크에 특화된 코드를 가질 수 없고<br>
비즈니스 규칙에 집중할수 있다. 그래서 도메인 코드를 자유롭게 모델링할 수 있다.

## 육각형 아키텍처(헥사고날 아키첵처)

---

```text
                _________________________
               /                         \
웹 어뎁터 -> [입력 포트]   <-[유스케이스]->   [출력포트] <- 영속성 어뎁터
             /               ↓             \
            <             [엔티티]           >
             \               ↑             /
외부 어뎁터 -> [입력포트]    <-[유스케이스]->  [출력포트] <- 외부 시스템 어뎁터
                \________________________/
```

왼쪽에 있는 어댑터들은 어플리케이션을 주도하는 어댑터들이다.  
오른쪽에 있는 어댑터들은 애플리케이션에 의해 주도되는 어댑터들이다.

<br>

##### 애플리케이션 코어와 어댑터들 간의 통신기 가능하려면 애플리케이션 코어가 각각의 포트를 제공 해야 한다. 
`주도하는 어댑터`는 그러한 포트가 코어에 있는 유스케이스 클래스들에  
의해구현되고 호출되는 인터페이스가 될 것이고,  
`주도되는 어댑터`는 그러한 포트가 어댑터에 의해 구현되고 코어에 의해  
호출되는 인터페이스가 될 것 이다.

마지막 계층에는 도메인 엔티티가 위치한다. 



