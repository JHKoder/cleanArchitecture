
## SOLID
### 단일 책임 원칙 SRP

---

단일 책임 원칙의 실제 정의는 다음과 같다<br>
`컴포넌트를 변경하는 이유는 오직 하나 뿐이어야 한다.`<br>
보시다 시피 `책임`은 사실 `오로지 한 가지 일만 하는 것`보다는 `변경할 이유`로 해석해야 한다.<br>
<br>
아마도 단일 책임 원칙을  `단일 변경 이유 원칙`으로 바꿔야 할지도 모르겠다.

### 의존 역전 원칙 DIP

---

`코드상의 어떤 의존성이든 그 방향을 바꿀수(역전시킬 수)있다.`

사실 의존성의 양쪽 코드를 모두 제어할 수 있을 때만 의존성을 역전시킬 수 있다. <br>
만약 서드파티 라이브러리에 의존성이 있다면 해당 라이브러리를 제어할 수 없기<br>
때문에 이 의존성은 역전시킬 수 없다. 

- 도메인 코드를 '변경할 이유'의 개수를 줄여보자 




## 클린 아키텍처의 구조

---

> 웹 , 데이터베이스, UI, 외부 인터페이스 ,장치 
> ⬇
> > 컨트롤러, 게이트웨이, 프레젠터
> ⬇
> > > 유스케이스
> ⬇
> > > > 엔티티 


이 아키텍처에서 가장 주요한 규칙은 의존성 규칙으로, `계층간의 모든 의존성이 안쪽으로 향해`야 한다는 것이다.

유스케이스는 앞에서 서비스라고 불렸던 것들인데 단일 책임(즉, 변경할 단 한 가지의 이유)을<br>
갖기 위해 조금 더 세분화돼 있다. 이를 통해 넓은 서비스의 문제를 피할 수 있다.

도메인 코드에서는 어떤 것이 사용되는지 알 수 없기 때문에 특정 프레임워크에 특화된 코드를 가질 수 없고<br>
비즈니스 규칙에 집중할수 있다. 그래서 도메인 코드를 자유롭게 모델링할 수 있다.

## 육각형 아키텍처(헥사고날 아키첵처)

---

```text
                _________________________
               /                         \
웹 어뎁터 -> [입력 포트]   <-[유스케이스]->   [출력포트] <- 영속성 어뎁터
             /               ↓             \
            <             [엔티티]           >
             \               ↑             /
외부 어뎁터 -> [입력포트]    <-[유스케이스]->  [출력포트] <- 외부 시스템 어뎁터
                \________________________/
```

왼쪽에 있는 어댑터들은 어플리케이션을 주도하는 어댑터들이다.  
오른쪽에 있는 어댑터들은 애플리케이션에 의해 주도되는 어댑터들이다.

<br>

##### 애플리케이션 코어와 어댑터들 간의 통신기 가능하려면 애플리케이션 코어가 각각의 포트를 제공 해야 한다. 
`주도하는 어댑터`는 그러한 포트가 코어에 있는 유스케이스 클래스들에  
의해구현되고 호출되는 인터페이스가 될 것이고,  
`주도되는 어댑터`는 그러한 포트가 어댑터에 의해 구현되고 코어에 의해  
호출되는 인터페이스가 될 것 이다.

마지막 계층에는 도메인 엔티티가 위치한다. 



